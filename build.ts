import * as esbuild from 'esbuild'
import * as fs from 'fs'
import { basename } from 'path'
import * as yaml from 'js-yaml'

const entryPoint: string = 'src/main.ts'
const outfile: string = 'dist/index.js'
const appsscriptJsonSrc: string = 'src/appsscript.json'
const appsscriptJsonDest: string = 'dist/appsscript.json'
const distDir: string = 'dist'

/**
 * Builds the Google Apps Script project using esbuild.
 * This function bundles the TypeScript source code into a single JavaScript file,
 * copies the appsscript.json manifest, and handles any build errors.
 */
async function buildGasProject(): Promise<void> {
    try {
        if (!fs.existsSync(distDir)) {
            fs.mkdirSync(distDir, { recursive: true })
            console.log(`[INFO] Created directory: ${distDir}`)
        }

        const promptsYamlPath = 'src/prompts.yaml'
        const loadedPromptsPath = 'src/loadedPrompts.ts'
        try {
            const yamlContent = fs.readFileSync(promptsYamlPath, 'utf8')
            const parsedPrompts = yaml.load(yamlContent)
            if (parsedPrompts === null || typeof parsedPrompts === 'undefined') {
                throw new Error('Parsed YAML content is null or undefined.')
            }
            const tsContent = `// This file is auto-generated by build.ts. Do not edit directly.\n` +
                `// Loaded from: ${promptsYamlPath}\n` +
                `export const PROMPTS: any = ${JSON.stringify(parsedPrompts, null, 2)};\n`
            fs.writeFileSync(loadedPromptsPath, tsContent, 'utf8')
            console.log(`[INFO] Loaded and parsed prompts from ${promptsYamlPath} into ${loadedPromptsPath}`)
        } catch (e: any) {
            console.error(`[ERROR] Failed to process prompts YAML file: ${promptsYamlPath}`)
            console.error(e.message || e)
            process.exit(1)
        }

        const buildOptions = {
            entryPoints: [entryPoint],
            bundle: true,
            outfile: outfile,
            format: 'iife',
            globalName: 'GasTemporaryExports',
            banner: {
                js: `// Bundled by esbuild for Google Apps Script at ${new Date().toISOString()}\n` +
                    `// Build script: ${basename(__filename)}`
            },
            footer: {
                // Footer to make bundled code GAS-friendly:
                // 1. Expose all bundled exports to the global scope.
                // 2. Ensure 'main' is globally available as a function for GAS triggers.
                js: `for (const key in GasTemporaryExports) {\n` +
                    `    if (Object.prototype.hasOwnProperty.call(GasTemporaryExports, key)) this[key] = GasTemporaryExports[key];\n` +
                    `}\n` +
                    `function main() { return GasTemporaryExports.main(); }`
            },
            define: { global: 'globalThis' },
            logLevel: 'info',
        } satisfies esbuild.BuildOptions

        await esbuild.build(buildOptions)
        console.log(`[SUCCESS] esbuild bundled ${entryPoint} to ${outfile}`)

        fs.copyFileSync(appsscriptJsonSrc, appsscriptJsonDest)
        console.log(`[SUCCESS] Copied ${appsscriptJsonSrc} to ${appsscriptJsonDest}`)
    } catch (error: unknown) {
        console.error('[ERROR] Build process failed:')
        if (error && typeof error === 'object' && 'errors' in error && Array.isArray((error as esbuild.BuildFailure).errors)) {
            const buildFailure = error as esbuild.BuildFailure
            buildFailure.errors.forEach((err: esbuild.Message) => {
                let message: string = `  - ${err.text}`
                if (err.location) message += ` (file: ${err.location.file}, line: ${err.location.line}, column: ${err.location.column})`
                console.error(message)
            })
        } else {
            console.error(error instanceof Error ? error.message : String(error))
        }
        process.exit(1)
    }
}
buildGasProject()
